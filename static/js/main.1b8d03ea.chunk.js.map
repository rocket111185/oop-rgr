{"version":3,"sources":["components/MainWrapper.jsx","components/FuncPlot.jsx","App.js","index.js","components/InputField.jsx"],"names":["sin","Math","cos","tan","sqrt","abs","exp","fieldValues","func","min","max","delimeter","strToFn","str","eval","TIMEOUT","MainWrapper","props","state","setNewValue","bind","handleFunc","handleMin","handleMax","handleDelimeter","key","value","this","setTimeout","field","newValue","includes","Error","mathFunc","parsed","parseFloat","isNaN","setState","e","alert","message","event","target","className","label","initValue","onChange","React","Component","FuncPlot","prevProps","mn","mx","num","ceil","norm","axe","Array","fill","map","_","i","trace","x","y","z","row","type","data","layout","width","height","title","App","ReactDOM","render","StrictMode","document","getElementById","InputField","handleChange"],"mappings":"iqEAwCQA,IAAkCC,KAAlCD,IAAKE,IAA6BD,KAA7BC,IAAKC,IAAwBF,KAAxBE,IAAKC,KAAmBH,KAAnBG,KAAMC,IAAaJ,KAAbI,IAAKC,IAAQL,KAARK,IAY5BC,YAAc,CAClBC,KAAM,kBACNC,IAAK,EACLC,IAAK,GACLC,UAAW,GAkBPC,QAAU,SAAVA,QAAUC,KAAG,OAAIC,KAAK,aAAeD,MAErCE,QAAU,I,kMAYKC,Y,mWAWnB,WAAYC,GAAQ,IAAD,0LAMjB,cAAMA,GANW,kOANX,IAkBN,EAAKC,MAAQX,YAKb,EAAKY,YAAc,EAAKA,YAAYC,KAAjB,oLACnB,EAAKC,WAAa,EAAKA,WAAWD,KAAhB,oLAClB,EAAKE,UAAY,EAAKA,UAAUF,KAAf,oLACjB,EAAKG,UAAY,EAAKA,UAAUH,KAAf,oLACjB,EAAKI,gBAAkB,EAAKA,gBAAgBJ,KAArB,oLArBN,E,kNA8BPK,EAAKC,GAAQ,IAAD,OAKtBnB,YAAYkB,GAAOC,IAQjB,qLAAAC,KAAF,cAEAC,YAAW,aAEP,uLAAF,cAEA,IAAIC,EAAQ,GAEZ,GAAmB,IAAf,uLAAI,OAAJ,OAEF,IAEE,IAAK,IAAMJ,KAAOlB,YAAa,CAE7BsB,EAAQJ,EAER,IAAMK,EAAWvB,YAAYkB,GAE7B,GAAY,SAARA,EAAgB,CAGlB,GAAIK,EAASC,SAAS,KAEpB,MAAM,IAAIC,MAAM,yBAIlB,GAA8B,kBAFbpB,QAAQkB,EAEdG,CAAS,EAAG,GAErB,MAAM,IAAID,MAAM,8BAEb,CAEL,IAAME,EAASC,WAAWL,GAE1B,GAAIM,MAAMF,GAER,MAAM,IAAIF,MAAM,sBAElBzB,YAAYkB,GAAOS,GAIvB,EAAKG,UAAS,kBAAM9B,eACpB,MAAO+B,GAEPC,MAAMV,EAAQ,KAAOS,EAAEE,YAG1BzB,W,iCAIM0B,GAETd,KAAKR,YAAY,OAAQsB,EAAMC,OAAOhB,S,gCAI9Be,GACRd,KAAKR,YAAY,MAAOsB,EAAMC,OAAOhB,S,gCAI7Be,GACRd,KAAKR,YAAY,MAAOsB,EAAMC,OAAOhB,S,sCAIvBe,GACdd,KAAKR,YAAY,YAAasB,EAAMC,OAAOhB,S,+BAK3C,IAAMO,EAAWrB,QAAQe,KAAKT,MAAMV,MAEpC,OACE,6EACE,mEAAKmC,UAAU,YAAf,UACE,2DAAC,gDAAD,CAAYC,MAAM,6CAChBC,UAAYlB,KAAKT,MAAMV,KACvBsC,SAAWnB,KAAKN,aAClB,2DAAC,gDAAD,CAAYuB,MAAM,8FAChBC,UAAYlB,KAAKT,MAAMT,IACvBqC,SAAWnB,KAAKL,YAClB,2DAAC,gDAAD,CAAYsB,MAAM,wFAChBC,UAAYlB,KAAKT,MAAMR,IACvBoC,SAAWnB,KAAKJ,YAClB,2DAAC,gDAAD,CAAYqB,MAAM,6CAChBC,UAAYlB,KAAKT,MAAMP,UACvBmC,SAAWnB,KAAKH,qBAEpB,2DAAC,6CAAD,CAAUhB,KAAOyB,EAAWxB,IAAMkB,KAAKT,MAAMT,IAC3CC,IAAKiB,KAAKT,MAAMR,IAAMC,UAAYgB,KAAKT,MAAMP,mB,GApJdoC,6CAAMC,Y,kJCpF1BC,E,kDACnB,WAAYhC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,CACXV,KAAMS,EAAMT,KACZC,IAAKQ,EAAMR,IACXC,IAAKO,EAAMP,IACXC,UAAWM,EAAMN,WANF,E,+DAcAuC,GAEbvB,KAAKV,QAAUiC,GAEjBvB,KAAKU,SAAS,CACZ7B,KAAMmB,KAAKV,MAAMT,KACjBC,IAAKkB,KAAKV,MAAMR,IAChBC,IAAKiB,KAAKV,MAAMP,IAChBC,UAAWgB,KAAKV,MAAMN,c,+BAMnB,MAE+BgB,KAAKT,MAAnCV,EAFD,EAECA,KAAMC,EAFP,EAEOA,IAAKC,EAFZ,EAEYA,IAAKC,EAFjB,EAEiBA,UAFjB,EAaaF,EAAMC,EACxB,CAAED,EAAKC,GACP,CAAEA,EAAKD,GAfF,mBAaC0C,EAbD,KAaKC,EAbL,KAiBDC,EAAMpD,KAAKqD,MAAMF,EAAKD,EAAK,GAAKxC,GAEhC4C,EAAO,SAAA7B,GAAK,OAAIA,EAAQf,EAAYwC,GAOpCK,EAAMC,MAAMJ,GACfK,KAAK,GACLC,KAAI,SAACC,EAAGC,GAAJ,OAAUN,EAAKM,MAiBhBC,EAAQ,CAAC,CACbC,EAAGP,EACHQ,EAAGR,EACHS,EAZaR,MAAMJ,GAClBK,KAAK,GACLC,KAAI,SAACO,EAAKF,GAAN,OAAYP,MAAMJ,GACpBK,KAAK,GACLC,KAAI,SAACC,EAAGG,GAAJ,OAAUvD,EAAK+C,EAAKQ,GAAIR,EAAKS,UASpCG,KAAM,YAGR,OACE,cAAC,IAAD,CACEC,KAAON,EACPO,OAAQ,CACNC,MAAO,IACPC,OAAQ,IACRC,MAAO,4F,GAvFqBzB,IAAMC,Y,kKC0C7ByB,MAhCf,WA0BE,OAAO,cAACzD,EAAA,EAAD,KCnCT0D,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,U,+HCLLC,G,wDACnB,WAAY9D,GAAQ,IAAD,8BACjB,cAAMA,IAEDC,MAAQ,CACXQ,MAAOT,EAAM4B,WAEf,EAAKmC,aAAe,EAAKA,aAAa5D,KAAlB,gBANH,E,yDAUNqB,GACXd,KAAKU,SAAS,CACZX,MAAOe,EAAMC,OAAOhB,U,+BAkBtB,OACE,qBAAKiB,UAAU,aAAaG,SAAWnB,KAAKV,MAAM6B,SAAlD,SACE,kCACInB,KAAKV,MAAM2B,MACb,uBAAOuB,KAAK,OAAOzC,MAAQC,KAAKT,MAAMQ,MACpCoB,SAAWnB,KAAKqD,wB,GApCYjC,IAAMC,c","file":"static/js/main.1b8d03ea.chunk.js","sourcesContent":["// Імпортуємо Реакт\nimport React from 'react';\n// Імпортуємо наші компоненти, а саме:\n// * елемент з графіком\nimport FuncPlot from './FuncPlot.jsx';\n// * елемент поля введення інформації\nimport InputField from './InputField.jsx';\n// Імпортуємо стилі\nimport './MainWrapper.css';\n\n/*\n * Декомпозиція дозволяє витягнути із об'єкта\n * властивості та оголосити їх як змінні.\n * Наприклад:\n *\n * const obj = { name: 'Foo', age: 42 };\n * const { name, age } = obj;\n * console.log(name); // Foo\n * console.log(age);  // 42\n *\n * Тим же чином витягнемо математичні функції\n * із вбудованого об'єкта Math, щоб у рядку\n * писати sin(x), cos(y) замість\n * Math.sin(x), Math.cos(y).\n *\n * Можна помітити цікавий коментар\n * // eslint-disable-next-line\n * Взагалі, на саму роботу коду він не впливає,\n * але я прописав доволі строгу конфігурацію\n * лінтера (перевірка на стиль коду).\n * Лінтер зафіксував, що я оголосив ці змінні,\n * але в коді їх ніде не застосував (лінтер\n * не знає, що вони будуть застосовані згодом),\n * і тому не дає зкомпілювати код.\n * Цей коментар повідомляє, що стрічку коду\n * після цього коментаря лінтер не повинен\n * перевіряти.\n */\n\n// eslint-disable-next-line\nconst { sin, cos, tan, sqrt, abs, exp } = Math;\n\n/*\n * Оголосимо об'єкт fieldValues, який зберігатиме такі властивості:\n * func - функція, для якої будуватиметься графік\n * min - початкова точка відліку X та Y\n * max - кінцева точка відліку X та Y\n * delimeter - дільник, тобто, покажчик кроку, з яким\n * будуватиметься графік\n *\n * min та max взаємнозамінні (про це в FuncPlot.jsx)\n */\nconst fieldValues = {\n  func: 'x ** 2 + y ** 2',\n  min: 0,\n  max: 20,\n  delimeter: 1\n};\n\n/*\n * strToFn(str)\n * str - стрічка (Стрінг), яка містить функцію.\n * Повертає функцію, якою можна користуватись для обчислень\n * в контексті JS.\n *\n * eval перетворює стрічку на функцію.\n * Забув сказати, що для новітнього JS функція може бути\n * записана як:\n * (аргументи) => { тіло функції }\n * (аргументи) => значення, яке повернеться із функції\n * аргумент => значення, яке повернеться із функції\n *\n * Таким чином, функція присвоєна у змінну strToFn.\n */\nconst strToFn = str => eval('(x, y) => ' + str);\n\nconst TIMEOUT = 4000;\n\n/*\n * export - вмонтований об'єкт, який містить усі змінні,\n * які будуть експортовані в інший файл.\n * export default - лише цей клас буде експортовано.\n * class MainWrapper - клас ГоловнаОбгортка (містить\n * все те, що буде зображено на сайті).\n * extends React.Component - походить від класу Компонент\n * бібліотеки Реакт.\n * Таким чином, це - класовий компонент Реакту.\n */\nexport default class MainWrapper extends React.Component {\n  /* Приватна змінна lock фіксує момент, коли треба\n   * перебудувати графік.\n   * Про це більше згодом.\n   */\n  #lock = 0;\n  /*\n   * Конструктор компоненту Реакт.\n   * Приймає властивості (props), які були згадані\n   * у файлі App.js\n   */\n  constructor(props) {\n    /*\n     * Викликаємо батьківський конструктор, передаємо властивості.\n     * Нагадаю, що їх для цього компонента нема, але все одно\n     * так варто робити.\n     */\n    super(props);\n\n    /*\n     * До стану компоненту присвоюємо об'єкт, який містить\n     * всі необхідні властивості.\n     */\n    this.state = fieldValues;\n    /*\n     * Прив'яжемо усі методи класу до контексту this.\n     * Дещо тупо, але це JS.\n     */\n    this.setNewValue = this.setNewValue.bind(this);\n    this.handleFunc = this.handleFunc.bind(this);\n    this.handleMin = this.handleMin.bind(this);\n    this.handleMax = this.handleMax.bind(this);\n    this.handleDelimeter = this.handleDelimeter.bind(this);\n  }\n\n  /*\n   * Метод setNewValue відповідає за зміну стану\n   * залежно від переданих значень.\n   * key - назва ключа\n   * value - значення, яке передається\n   */\n  setNewValue(key, value) {\n    /*\n     * Присвоїмо у об'єкт до відповідного ключа відповідне значення.\n     * Прошу помітити, що стан ще не змінився.\n     */\n    fieldValues[key] = value;\n    /*\n     * А тепер щодо lock.\n     * Ця змінна визначає, коли саме можна буде змінювати стан.\n     * При кожній зміні значення у полі вводу ця величина збільшується.\n     * Це дає змогу змінювати стан лише тоді, коли користувач нічого\n     * не вводить протягом TIMEOUT мілісекунд.\n     */\n    ++this.#lock;\n    // setTimeout(функція, перерва у мс)\n    setTimeout(() => {\n      // Зменшуємо lock\n      --this.#lock;\n      // Оголосимо змінну, яка зберігатиме назву поля, на якому виникла помилка\n      let field = '';\n      // Якщо lock дорівнює нулю (рівно 4 секунди користувач нічого не вводив)\n      if (this.#lock === 0) {\n        // Цей шмат коду може викинути помилку, відловлюємо\n        try {\n          // Цикл проходиться по ключах об'єкту fieldValues\n          for (const key in fieldValues) {\n            // Записуємо назву поля (ключа)\n            field = key;\n            // newValue (новеЗначення), тому що воно нове відносно стану\n            const newValue = fieldValues[key];\n            // Якщо ключ -- func (функція)\n            if (key === 'func') {\n              // Якщо у функції присутні крапки з комою\n              // (потенційно небезпечний код)\n              if (newValue.includes(';'))\n                // викидаємо помилку \"крапка з комою заборонена\"\n                throw new Error('semicolon is rejected');\n              // Тепер утворимо функцію зі стрічки\n              const mathFunc = strToFn(newValue);\n              // Якщо функція не повертає число\n              if (typeof mathFunc(0, 0) !== 'number')\n                // Робимо користувачу \"а-тя-тя\"\n                throw new Error('should return a number');\n            // Якщо ключ -- один із min, max, delimeter\n            } else {\n              // Перетворимо стрічку на числовий тип (допускаємо плаваючу кому)\n              const parsed = parseFloat(newValue);\n              // Якщо отримане значення -- не число\n              if (isNaN(parsed))\n                // \"має бути числом\"\n                throw new Error('should be a number');\n              // В іншому разі, спокійно присвоюємо\n              fieldValues[key] = parsed;\n            }\n          }\n          // Змінимо стан на новий\n          this.setState(() => fieldValues);\n        } catch (e) {\n          // Якщо помилка таки сталась, то показуємо повідомлення\n          alert(field + ': ' + e.message);\n        }\n      }\n    }, TIMEOUT);\n  }\n\n  // Функція, яка отримує нове значення від поля \"Функція\"\n  handleFunc(event) {\n    // Передаємо отримане значення з відповідним ключем\n    this.setNewValue('func', event.target.value);\n  }\n\n  // Від поля \"Початок проміжку\"\n  handleMin(event) {\n    this.setNewValue('min', event.target.value);\n  }\n\n  // Від поля \"Кінець проміжку\"\n  handleMax(event) {\n    this.setNewValue('max', event.target.value);\n  }\n\n  // Від поля \"Ділення\"\n  handleDelimeter(event) {\n    this.setNewValue('delimeter', event.target.value);\n  }\n\n  render() {\n    // Перетворимо стрічку з функцією в дійсну функцію\n    const mathFunc = strToFn(this.state.func);\n    // Повертаємо оцю купу компонентів (якщо їх багато, обгортаємо в <div>)\n    return (\n      <div>\n        <div className=\"inputForm\">\n          <InputField label=\"Функція\"\n            initValue={ this.state.func }\n            onChange={ this.handleFunc } />\n          <InputField label=\"Початок проміжку\"\n            initValue={ this.state.min }\n            onChange={ this.handleMin } />\n          <InputField label=\"Кінець проміжку\"\n            initValue={ this.state.max }\n            onChange={ this.handleMax } />\n          <InputField label=\"Ділення\"\n            initValue={ this.state.delimeter }\n            onChange={ this.handleDelimeter } />\n        </div>\n        <FuncPlot func={ mathFunc } min={ this.state.min }\n          max={this.state.max } delimeter={ this.state.delimeter } />\n      </div>\n    );\n  }\n}\n","import React from 'react';\n// Імпортуємо залежність, яка і будує графіки\nimport Plot from 'react-plotly.js';\n\nexport default class FuncPlot extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      func: props.func,\n      min: props.min,\n      max: props.max,\n      delimeter: props.delimeter\n    };\n  }\n\n  /*\n   * При оновленні підкомпоненти оновлюється вся компонента,\n   * яка містить ту саму підкомпоненту (викликається render()).\n   */\n  componentDidUpdate(prevProps) {\n    //Якщо це не один і той самий об'єкт з властивостями\n    if (this.props !== prevProps) {\n      // Установлюємо новий стан\n      this.setState({\n        func: this.props.func,\n        min: this.props.min,\n        max: this.props.max,\n        delimeter: this.props.delimeter\n      });\n    }\n    // Така перевірка дає уникнути безкінечний цикл\n  }\n\n  render() {\n    // Витагуємо все, що нам треба\n    const { func, min, max, delimeter } = this.state;\n    /*\n     * А ось тут про взаємозамінність.\n     * Якщо кінець проміжку більший, ніж початок, міняємо місцями,\n     * але при цьому усе присвоюється до нових змінних mn, mx.\n     * Але чому квадратні дужки, а не фігурні, як це було вище?\n     * Тому що фігурні дужки - це об'єкт, і там чітка прив'язка\n     * до імен (ключів).\n     * Квадратні - це масив, і там нема прив'язки до імен змінних,\n     * а лише до позицій.\n     */\n    const [ mn, mx ] = (min < max) ?\n      [ min, max ] :\n      [ max, min ];\n    // Кількість елементів в масиві\n    const num = Math.ceil((mx - mn + 1) / delimeter);\n    // Функція, яка нормалізує значення (значення ітерації в абсолютне)\n    const norm = value => value * delimeter + mn;\n    /*\n     * Масив індексів осей x, y\n     * Спочатку створюється порожній масив з фіксованоб довжиною\n     * num, потім наповнюється нулями, а потім кожне значення ітеративно\n     * замінюється на відповідне значення осі.\n     */\n    const axe = Array(num)\n      .fill(0)\n      .map((_, i) => norm(i));\n    /*\n     * Матриця значень\n     * Спочатку створюємо масив, наповнюємо нулями, а потім\n     * створюємо підмасиви тієї ж довжини, що і головний масив,\n     * наповнюємо нулями, а потім ітеративно наповнюємо результатами\n     * функції залежно від нормалізованих значень x та y.\n     */\n    const values = Array(num)\n      .fill(0)\n      .map((row, y) => Array(num)\n        .fill(0)\n        .map((_, x) => func(norm(x), norm(y))));\n    /*\n     * Об'єкт з властивостями графіка, який потім буде передано\n     * в компонент Plot.\n     */\n    const trace = [{\n      x: axe,\n      y: axe,\n      z: values,\n      type: 'surface'\n    }];\n    // Повертаємо графік\n    return (\n      <Plot\n        data={ trace }\n        layout={{\n          width: 900,\n          height: 800,\n          title: 'Графік 3D функції'\n        }}\n      />\n    );\n  }\n}\n","// Імпортуємо Реакт\nimport React from 'react';\n/*\n * Імпортуємо компонент ГоловнаОбгортка\n * Більше - дивіться файл MainWrapper.jsx\n */\nimport MainWrapper from './components/MainWrapper.jsx';\n\n/*\n * Створюємо функціональний компонент Додаток (App),\n * який є вхідною точкою будь-якого додатку Реакт\n * (щось на кшталт int main).\n */\n\nfunction App() {\n  /*\n   * В Реакті усе - компонент.\n   * Але що таке компонент?\n   * Це абстрактна складова сайту.\n   * Таким чином, App - це головний компонент.\n   * Компоненти поділяються на 2 типи: функціональний та класовий.\n   * App має бути обов'язково функціональним, це умова Реакту.\n   * Функціональні компоненти повертають компонент одразу ж,\n   * і вони не мають стану, на відміну від класових.\n   * Стан - це властивості компоненту, які залежно від ситуації\n   * можуть змінюватись на ходу (ось це і є фішкою Реакту).\n   *\n   * Будь-який компонент у Реакті може оголошуватись двома способами:\n   * React.createElement(НазваКомпоненту, [властивості], [...нащадки]);\n   * або\n   * <НазваКомпоненту властивість1={ значення1 } властивість2={ значення2 } >\n   *  ...нащадки\n   * <НазваКомпоненту />\n   * Другий варіант називається JSX (JS eXtension, розширення JavaScript).\n   *\n   * Якщо нащадків нема, то можна зробити і так:\n   * <НазваКомпоненту властивість1={ значення1 } властивість2=\"значення2\"... />\n   * В даному випадку створюється компонент MainWrapper\n   * без нащадків та властивостей.\n   */\n  return <MainWrapper />;\n}\n\n/*\n * Цей компонент експортується, причому за умовчуванням.\n */\nexport default App;\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","import React from 'react';\nimport './InputField.css';\n\n// Компонент \"ПолеВводу\"\nexport default class InputField extends React.Component {\n  constructor(props) {\n    super(props);\n    // В цьому разі, до стану присвоєно анонімний об'єкт\n    this.state = {\n      value: props.initValue\n    };\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  // Ця функція оновлює стан компоненту\n  handleChange(event) {\n    this.setState({\n      value: event.target.value\n    });\n  }\n\n  render() {\n    /*\n     * На жаль, всередині JSX виразів не можна вставляти коментарі,\n     * тому я поясню деякі деталі тут.\n     * className - це властивість, яка в HTML уже носить назву class.\n     * Вона дає змогу надати клас компоненті для того, щоб можна було\n     * застосувати стилі до усього класу.\n     *\n     * onChange - функція, яка викликатиметься кожного разу, коли змінюється\n     * стан компоненти.\n     * Оскільки input - це лише підкомпонента InputField, то нам треба\n     * вручну прописати код, який оновлюватиме стан InputField при оновленні\n     * стану input.\n     */\n    return (\n      <div className=\"inputField\" onChange={ this.props.onChange }>\n        <label>\n          { this.props.label }\n          <input type=\"text\" value={ this.state.value }\n            onChange={ this.handleChange } />\n        </label>\n      </div>\n    );\n  }\n}\n"],"sourceRoot":""}